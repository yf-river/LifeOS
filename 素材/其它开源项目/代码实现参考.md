# 5个参考项目 - 代码级别实现参考

本文档提供具体的代码示例和实现模式，供 Prism 重构时直接参考。

---

## 1. API 设计参考

### 1.1 gRPC-Gateway 模式 (memos)

**优势**: 类型安全 + 自动生成 REST API

**Protocol Buffer 定义** (`memo_service.proto`):
```protobuf
syntax = "proto3";
package v1;

import "google/api/annotations.proto";

message Memo {
  int32 id = 1;
  string content = 2;
  int64 created_time = 3;
  int64 updated_time = 4;
  string creator_id = 5;
  string visibility = 6;  // PRIVATE, SHARED, PUBLIC
}

message CreateMemoRequest {
  string content = 1;
  string visibility = 2;
}

service MemoService {
  rpc ListMemos(ListMemosRequest) returns (ListMemosResponse) {
    option (google.api.http) = {
      get: "/api/v1/memos"
    };
  }
  
  rpc CreateMemo(CreateMemoRequest) returns (Memo) {
    option (google.api.http) = {
      post: "/api/v1/memos"
      body: "*"
    };
  }
  
  rpc GetMemo(GetMemoRequest) returns (Memo) {
    option (google.api.http) = {
      get: "/api/v1/memos/{id}"
    };
  }
  
  rpc UpdateMemo(UpdateMemoRequest) returns (Memo) {
    option (google.api.http) = {
      patch: "/api/v1/memos/{id}"
      body: "*"
    };
  }
  
  rpc DeleteMemo(DeleteMemoRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/api/v1/memos/{id}"
    };
  }
}
```

**Go 服务实现**:
```go
type MemoService struct {
  store Store
}

func (s *MemoService) ListMemos(ctx context.Context, req *ListMemosRequest) (*ListMemosResponse, error) {
  // 从数据库查询
  memos, err := s.store.QueryMemos(ctx, req.Limit, req.Offset)
  if err != nil {
    return nil, status.Errorf(codes.Internal, "failed to query memos: %v", err)
  }
  
  return &ListMemosResponse{
    Memos: memos,
    Total: int32(len(memos)),
  }, nil
}

func (s *MemoService) CreateMemo(ctx context.Context, req *CreateMemoRequest) (*Memo, error) {
  // 验证
  if req.Content == "" {
    return nil, status.Errorf(codes.InvalidArgument, "content is required")
  }
  
  // 创建
  memo := &Memo{
    Content:    req.Content,
    Visibility: req.Visibility,
    CreatedTime: time.Now().Unix(),
  }
  
  // 保存
  id, err := s.store.CreateMemo(ctx, memo)
  if err != nil {
    return nil, status.Errorf(codes.Internal, "failed to create memo: %v", err)
  }
  
  memo.Id = id
  return memo, nil
}
```

**优势**:
- 单一定义 (Proto) 生成 gRPC 和 REST
- 类型安全
- 自动生成 Swagger/OpenAPI 文档
- 向后兼容

---

### 1.2 tRPC 模式 (blinko)

**优势**: TypeScript 前后端类型共享

**后端定义** (`trpc/router.ts`):
```typescript
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.create();
export const router = t.router;
export const publicProcedure = t.procedure;

// Schema 定义
const MemoSchema = z.object({
  id: z.string(),
  content: z.string(),
  createdAt: z.date(),
  tags: z.array(z.string()),
});

type Memo = z.infer<typeof MemoSchema>;

// API 定义
export const appRouter = router({
  memo: router({
    list: publicProcedure
      .input(z.object({ 
        limit: z.number().default(10),
        offset: z.number().default(0),
        tags: z.array(z.string()).optional(),
      }))
      .query(async ({ input }) => {
        // 查询逻辑
        const memos = await db.memo.findMany({
          take: input.limit,
          skip: input.offset,
          where: input.tags ? {
            tags: { some: { name: { in: input.tags } } }
          } : undefined,
        });
        return memos;
      }),
    
    create: publicProcedure
      .input(z.object({
        content: z.string(),
        tags: z.array(z.string()).optional(),
      }))
      .mutation(async ({ input }) => {
        const memo = await db.memo.create({
          data: {
            content: input.content,
            tags: {
              connectOrCreate: input.tags?.map(tag => ({
                where: { name: tag },
                create: { name: tag },
              })) || [],
            },
          },
        });
        return memo;
      }),
    
    search: publicProcedure
      .input(z.object({
        query: z.string(),
        limit: z.number().default(10),
      }))
      .query(async ({ input }) => {
        // 向量搜索
        const results = await vectorSearch(input.query, input.limit);
        return results;
      }),
  }),
});

export type AppRouter = typeof appRouter;
```

**前端使用** (自动类型推断):
```typescript
import { trpc } from '@/trpc/client';

// 自动类型推断!
export function MemoList() {
  const { data: memos, isLoading } = trpc.memo.list.useQuery({ 
    limit: 20 
  });
  
  const createMemo = trpc.memo.create.useMutation();
  
  const handleCreate = async (content: string) => {
    await createMemo.mutateAsync({ content });
    // 类型安全，IDE 会提示必需的字段
  };
  
  return (
    <div>
      {memos?.map(memo => (
        <div key={memo.id}>
          <p>{memo.content}</p>
          <span>{memo.createdAt.toLocaleDateString()}</span>
        </div>
      ))}
    </div>
  );
}
```

**优势**:
- TypeScript 类型自动同步
- 零运行时开销
- 完美的 IDE 支持
- 减少 API 文档维护

---

## 2. 数据库设计参考

### 2.1 Prisma Schema (blinko)

```prisma
// prisma/schema.prisma

datasource db {
  provider = "sqlite"  // 或 "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// 笔记表
model Memo {
  id        String   @id @default(cuid())
  content   String   @db.Text
  markdown  String?  @db.Text
  
  // 关系
  tags      Tag[]    @relation("MemoToTag")
  reactions Reaction[]
  relations MemoRelation[]
  
  // 搜索优化
  fullText  String?  @db.Text  // 用于全文索引
  
  // 元数据
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
  
  // 用户隔离
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  
  // 可见性
  visibility String @default("PRIVATE")  // PRIVATE, SHARED, PUBLIC
  
  @@index([userId])
  @@index([createdAt])
  @@fulltext([content, markdown])  // MySQL 全文索引
}

// 标签表
model Tag {
  id    String @id @default(cuid())
  name  String @unique
  color String?
  
  memos Memo[] @relation("MemoToTag")
  
  @@index([name])
}

// 反应表 (Emoji, 点赞等)
model Reaction {
  id      String @id @default(cuid())
  emoji   String
  count   Int    @default(1)
  
  memoId  String
  memo    Memo   @relation(fields: [memoId], references: [id], onDelete: Cascade)
  
  userId  String
  user    User   @relation(fields: [userId], references: [id])
  
  @@unique([memoId, userId, emoji])
  @@index([memoId])
}

// 关系表 (分享、收藏、引用)
model MemoRelation {
  id          String @id @default(cuid())
  
  sourceMemoId String
  sourceMemo   Memo   @relation("MemoSource", fields: [sourceMemoId], references: [id], onDelete: Cascade)
  
  targetMemoId String
  targetMemo   Memo   @relation("MemoTarget", fields: [targetMemoId], references: [id], onDelete: Cascade)
  
  relationType String  // SHARE, FAVORITE, REFERENCE, RELATED
  
  createdAt    DateTime @default(now())
  
  @@unique([sourceMemoId, targetMemoId, relationType])
  @@index([sourceMemoId])
  @@index([targetMemoId])
  
  relation MemoRelation
}

// 向量嵌入表 (用于语义搜索)
model MemoEmbedding {
  id        String @id @default(cuid())
  memoId    String @unique
  memo      Memo   @relation(fields: [memoId], references: [id], onDelete: Cascade)
  
  embedding Bytes  // 向量数据 (需要 pgvector 扩展 for PostgreSQL)
  model     String // 嵌入模型名称
  
  createdAt DateTime @default(now())
  
  @@index([memoId])
}

// 用户表
model User {
  id    String @id @default(cuid())
  email String @unique
  name  String?
  
  memos     Memo[]
  reactions Reaction[]
  
  createdAt DateTime @default(now())
}
```

**迁移命令**:
```bash
# 创建迁移
pnpm prisma migrate dev --name add_memo_table

# 生成 Prisma Client
pnpm prisma generate

# 查看数据库
pnpm prisma studio
```

---

### 2.2 PostgreSQL + PG Vector (生产)

```sql
-- 安装 pgvector 扩展
CREATE EXTENSION IF NOT EXISTS vector;

-- 笔记表
CREATE TABLE memos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  user_id UUID NOT NULL REFERENCES users(id),
  visibility VARCHAR(20) DEFAULT 'PRIVATE'
);

-- 向量嵌入表
CREATE TABLE memo_embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  memo_id UUID NOT NULL UNIQUE REFERENCES memos(id) ON DELETE CASCADE,
  embedding vector(384),  -- 384 维向量 (all-MiniLM-L6-v2)
  model_name VARCHAR(100) DEFAULT 'all-MiniLM-L6-v2'
);

-- 向量索引 (HNSW 算法)
CREATE INDEX memo_embedding_idx ON memo_embeddings 
USING hnsw (embedding vector_cosine_ops);

-- 标签表
CREATE TABLE tags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL UNIQUE
);

-- 笔记-标签关系表
CREATE TABLE memo_tags (
  memo_id UUID NOT NULL REFERENCES memos(id) ON DELETE CASCADE,
  tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
  PRIMARY KEY (memo_id, tag_id)
);

-- 创建索引
CREATE INDEX memo_user_idx ON memos(user_id);
CREATE INDEX memo_created_idx ON memos(created_at DESC);
CREATE INDEX memo_tags_idx ON memo_tags(tag_id);
```

**Go 查询示例**:
```go
import "github.com/pgvector/pgvector-go"

type MemoRepository struct {
  db *sql.DB
}

// 向量搜索
func (r *MemoRepository) SearchByVector(ctx context.Context, 
  embedding pgvector.Vector, limit int) ([]Memo, error) {
  
  query := `
    SELECT m.id, m.content, m.created_at,
           1 - (me.embedding <=> $1) as similarity
    FROM memos m
    JOIN memo_embeddings me ON m.id = me.memo_id
    WHERE m.visibility = 'PUBLIC'
    ORDER BY similarity DESC
    LIMIT $2
  `
  
  rows, err := r.db.QueryContext(ctx, query, embedding, limit)
  if err != nil {
    return nil, err
  }
  defer rows.Close()
  
  var memos []Memo
  for rows.Next() {
    var m Memo
    var similarity float32
    err := rows.Scan(&m.ID, &m.Content, &m.CreatedAt, &similarity)
    if err != nil {
      return nil, err
    }
    m.Similarity = similarity
    memos = append(memos, m)
  }
  
  return memos, nil
}

// 混合搜索 (向量 + 全文)
func (r *MemoRepository) HybridSearch(ctx context.Context,
  query string, embedding pgvector.Vector, limit int) ([]Memo, error) {
  
  hybridQuery := `
    SELECT m.id, m.content, m.created_at,
           COALESCE(ts_rank(m.textsearch, websearch_to_tsquery($1)), 0) * 0.3 +
           (1 - (me.embedding <=> $2)) * 0.7 as score
    FROM memos m
    JOIN memo_embeddings me ON m.id = me.memo_id
    WHERE m.textsearch @@ websearch_to_tsquery($1)
       OR (1 - (me.embedding <=> $2)) > 0.5
    ORDER BY score DESC
    LIMIT $3
  `
  
  rows, err := r.db.QueryContext(ctx, hybridQuery, query, embedding, limit)
  // ... 处理结果
}
```

---

## 3. 工作流引擎参考 (FastGPT 模式)

### 3.1 节点类型定义

```typescript
// workflow/types.ts

export enum NodeType {
  // I/O
  START = 'start',
  END = 'end',
  
  // AI
  LLM = 'llm',
  TOOL = 'tool',
  FUNCTION = 'function',
  
  // 数据
  RETRIEVAL = 'retrieval',  // 知识库检索
  DATABASE = 'database',    // 数据库查询
  
  // 控制
  IF = 'if',               // 条件分支
  LOOP = 'loop',           // 循环
  PARALLEL = 'parallel',   // 并行执行
  
  // 输出
  OUTPUT = 'output',
}

export interface WorkflowNode {
  id: string;
  type: NodeType;
  name: string;
  
  // 配置
  config: Record<string, any>;
  
  // I/O
  inputs: NodeInput[];
  outputs: NodeOutput[];
  
  // 位置 (可视化)
  position: { x: number; y: number };
}

export interface NodeInput {
  id: string;
  name: string;
  type: 'text' | 'number' | 'boolean' | 'json';
  required: boolean;
  default?: any;
  description?: string;
}

export interface NodeOutput {
  id: string;
  name: string;
  type: 'text' | 'number' | 'boolean' | 'json';
  description?: string;
}

export interface WorkflowEdge {
  id: string;
  source: string;      // 源节点 ID
  sourceHandle: string; // 输出端口
  target: string;       // 目标节点 ID
  targetHandle: string; // 输入端口
}

export interface Workflow {
  id: string;
  name: string;
  description?: string;
  
  nodes: WorkflowNode[];
  edges: WorkflowEdge[];
  
  // 元数据
  createdAt: Date;
  updatedAt: Date;
  version: number;
}
```

### 3.2 工作流执行引擎

```typescript
// workflow/executor.ts

export class WorkflowExecutor {
  private context: ExecutionContext = {};
  
  async execute(workflow: Workflow): Promise<ExecutionResult> {
    const startNode = workflow.nodes.find(n => n.type === NodeType.START);
    if (!startNode) throw new Error('No start node found');
    
    const executedNodes = new Set<string>();
    const nodeResults = new Map<string, any>();
    
    // 拓扑排序 + 执行
    return await this.executeNode(workflow, startNode.id, executedNodes, nodeResults);
  }
  
  private async executeNode(
    workflow: Workflow,
    nodeId: string,
    executedNodes: Set<string>,
    nodeResults: Map<string, any>
  ): Promise<ExecutionResult> {
    if (executedNodes.has(nodeId)) {
      return nodeResults.get(nodeId);
    }
    
    const node = workflow.nodes.find(n => n.id === nodeId)!;
    console.log(`[Workflow] Executing node: ${node.name} (${node.type})`);
    
    // 获取输入
    const inputs = await this.resolveInputs(workflow, node, nodeResults);
    
    // 执行节点
    let result: any;
    switch (node.type) {
      case NodeType.LLM:
        result = await this.executeLLM(node, inputs);
        break;
      case NodeType.RETRIEVAL:
        result = await this.executeRetrieval(node, inputs);
        break;
      case NodeType.IF:
        result = await this.executeIf(workflow, node, inputs, executedNodes, nodeResults);
        return result;  // 条件分支不存储结果
      case NodeType.PARALLEL:
        result = await this.executeParallel(workflow, node, inputs, executedNodes, nodeResults);
        break;
      case NodeType.END:
        return { output: inputs, status: 'completed' };
      default:
        throw new Error(`Unknown node type: ${node.type}`);
    }
    
    nodeResults.set(nodeId, result);
    executedNodes.add(nodeId);
    
    // 执行下游节点
    const nextNodes = this.getNextNodes(workflow, nodeId);
    for (const nextNode of nextNodes) {
      await this.executeNode(workflow, nextNode, executedNodes, nodeResults);
    }
    
    return result;
  }
  
  private async executeLLM(node: WorkflowNode, inputs: any) {
    const { model, prompt, temperature } = node.config;
    const llm = this.getLLMClient(model);
    
    return await llm.generate({
      prompt: this.interpolateTemplate(prompt, inputs),
      temperature: temperature || 0.7,
    });
  }
  
  private async executeRetrieval(node: WorkflowNode, inputs: any) {
    const { datasetId, topK = 5, similarity = 0.5 } = node.config;
    const query = inputs[node.inputs[0].id];
    
    const results = await this.vectorSearch(query, {
      datasetId,
      topK,
      minSimilarity: similarity,
    });
    
    return results;
  }
  
  private async executeIf(workflow: Workflow, node: WorkflowNode, inputs: any, 
    executedNodes: Set<string>, nodeResults: Map<string, any>) {
    
    const { condition } = node.config;
    const conditionResult = this.evaluateCondition(condition, inputs);
    
    const nextNodeId = conditionResult ? node.config.trueBranch : node.config.falseBranch;
    return await this.executeNode(workflow, nextNodeId, executedNodes, nodeResults);
  }
  
  private async executeParallel(workflow: Workflow, node: WorkflowNode, inputs: any,
    executedNodes: Set<string>, nodeResults: Map<string, any>) {
    
    const childNodes = workflow.edges
      .filter(e => e.source === node.id)
      .map(e => e.target);
    
    // 并行执行
    const results = await Promise.all(
      childNodes.map(childId => 
        this.executeNode(workflow, childId, executedNodes, nodeResults)
      )
    );
    
    return { parallel_results: results };
  }
  
  private getNextNodes(workflow: Workflow, nodeId: string): string[] {
    return workflow.edges
      .filter(e => e.source === nodeId)
      .map(e => e.target);
  }
  
  private interpolateTemplate(template: string, data: any): string {
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      return data[key] ?? match;
    });
  }
}
```

---

## 4. MCP (Model Context Protocol) 集成参考

### 4.1 作为 MCP 服务器 (Prism 可以提供)

```typescript
// mcp/server.ts

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { CallToolRequestSchema, ListToolsRequestSchema } from "@modelcontextprotocol/sdk/types.js";

const server = new Server({
  name: "prism-server",
  version: "1.0.0",
});

// 定义工具
const tools = [
  {
    name: "create_note",
    description: "创建一条笔记",
    inputSchema: {
      type: "object",
      properties: {
        content: { type: "string", description: "笔记内容" },
        tags: { type: "array", items: { type: "string" } },
      },
      required: ["content"],
    },
  },
  {
    name: "search_notes",
    description: "搜索笔记库",
    inputSchema: {
      type: "object",
      properties: {
        query: { type: "string", description: "搜索查询" },
        limit: { type: "number", description: "返回结果数量" },
      },
      required: ["query"],
    },
  },
  {
    name: "get_thinking_model",
    description: "获取思维模型库中的模型",
    inputSchema: {
      type: "object",
      properties: {
        model_id: { type: "string" },
        category: { type: "string" },
      },
    },
  },
  {
    name: "query_knowledge_graph",
    description: "查询知识图谱",
    inputSchema: {
      type: "object",
      properties: {
        query: { type: "string", description: "图谱查询" },
        depth: { type: "number", description: "遍历深度" },
      },
    },
  },
];

// 处理工具列表请求
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return { tools };
});

// 处理工具调用请求
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  switch (name) {
    case "create_note":
      return await createNote(args.content, args.tags);
    
    case "search_notes":
      return await searchNotes(args.query, args.limit || 10);
    
    case "get_thinking_model":
      return await getThinkingModel(args.model_id, args.category);
    
    case "query_knowledge_graph":
      return await queryKnowledgeGraph(args.query, args.depth || 2);
    
    default:
      throw new Error(`Unknown tool: ${name}`);
  }
});

// 工具实现
async function createNote(content: string, tags: string[]) {
  // 调用后端 API 创建笔记
  const response = await fetch("http://localhost:3000/api/notes", {
    method: "POST",
    body: JSON.stringify({ content, tags }),
  });
  return await response.json();
}

async function searchNotes(query: string, limit: number) {
  const response = await fetch(
    `http://localhost:3000/api/notes/search?q=${query}&limit=${limit}`
  );
  return await response.json();
}

async function getThinkingModel(modelId: string, category: string) {
  const params = new URLSearchParams();
  if (modelId) params.append("id", modelId);
  if (category) params.append("category", category);
  
  const response = await fetch(`http://localhost:3000/api/models?${params}`);
  return await response.json();
}

async function queryKnowledgeGraph(query: string, depth: number) {
  const response = await fetch("http://localhost:3000/api/graph/query", {
    method: "POST",
    body: JSON.stringify({ query, depth }),
  });
  return await response.json();
}

// 启动服务器
const transport = new StdioServerTransport();
await server.connect(transport);
```

### 4.2 作为 MCP 客户端 (连接外部工具)

```typescript
// 参考 blinko 的 McpClientManager

import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";

export class ExternalToolManager {
  private tools: Map<string, Tool> = new Map();
  
  async registerExternalMcpServer(config: {
    name: string;
    command: string;
    args: string[];
  }) {
    // 启动 MCP 服务器
    const transport = new StdioClientTransport({
      command: config.command,
      args: config.args,
    });
    
    const client = new Client({
      name: "prism-client",
      version: "1.0.0",
    });
    
    await client.connect(transport);
    
    // 列表化工具
    const tools = await client.listTools();
    
    for (const tool of tools.tools) {
      this.tools.set(`${config.name}:${tool.name}`, {
        ...tool,
        serverName: config.name,
        client,
      });
    }
  }
  
  async callTool(toolName: string, args: any): Promise<any> {
    const tool = this.tools.get(toolName);
    if (!tool) throw new Error(`Tool not found: ${toolName}`);
    
    return await tool.client.callTool({
      name: tool.name,
      arguments: args,
    });
  }
}
```

---

## 5. 向量搜索实现参考

### 5.1 混合搜索 (FastGPT 模式)

```typescript
// search/hybrid.ts

export class HybridSearch {
  constructor(
    private vectorDB: VectorDatabase,
    private fullTextSearch: FullTextSearch
  ) {}
  
  async search(query: string, options: {
    topK?: number;
    minVectorSimilarity?: number;
    minFtsScore?: number;
    weights?: {
      vector: number;
      fts: number;
    };
  } = {}): Promise<SearchResult[]> {
    const {
      topK = 10,
      minVectorSimilarity = 0.5,
      minFtsScore = 0.3,
      weights = { vector: 0.6, fts: 0.4 },
    } = options;
    
    // 1. 并行执行向量搜索和全文搜索
    const [vectorResults, ftsResults] = await Promise.all([
      this.vectorSearch(query, topK, minVectorSimilarity),
      this.fullTextSearch.search(query, topK, minFtsScore),
    ]);
    
    // 2. 合并结果
    const merged = this.mergeResults(vectorResults, ftsResults, weights);
    
    // 3. 重排 (可选，使用 LLM 或 reranker 模型)
    const reranked = await this.rerank(merged, query);
    
    return reranked.slice(0, topK);
  }
  
  private async vectorSearch(query: string, topK: number, minSimilarity: number) {
    // 1. 生成查询向量
    const queryVector = await this.generateEmbedding(query);
    
    // 2. 向量搜索
    const results = await this.vectorDB.search(queryVector, topK);
    
    // 3. 过滤低相似度
    return results.filter(r => r.similarity >= minSimilarity);
  }
  
  private async fullTextSearch(query: string, topK: number, minScore: number) {
    const results = await this.fullTextSearch.search(query, topK);
    return results.filter(r => r.score >= minScore);
  }
  
  private mergeResults(vectorResults: any[], ftsResults: any[], weights: any) {
    const merged = new Map<string, SearchResult>();
    
    // 添加向量搜索结果
    vectorResults.forEach((r, idx) => {
      merged.set(r.id, {
        ...r,
        score: r.similarity * weights.vector,
        source: 'vector',
        rank: idx,
      });
    });
    
    // 添加全文搜索结果
    ftsResults.forEach((r, idx) => {
      const existing = merged.get(r.id);
      if (existing) {
        // 合并分数
        existing.score += r.score * weights.fts;
        existing.source = 'hybrid';
      } else {
        merged.set(r.id, {
          ...r,
          score: r.score * weights.fts,
          source: 'fts',
          rank: idx,
        });
      }
    });
    
    // 按分数排序
    return Array.from(merged.values()).sort((a, b) => b.score - a.score);
  }
  
  private async rerank(results: SearchResult[], query: string) {
    // 使用 LLM 或专门的 reranker 模型重排
    // 例如 BGE-Reranker, Cohere Rerank 等
    
    const reranker = this.getReranker();
    return await reranker.rerank(results, query);
  }
}
```

---

## 6. 项目结构模板

### 推荐的 Prism 项目结构

```
prism-refactor/
├── backend/
│   ├── cmd/
│   │   └── main.go              # 应用入口
│   ├── internal/
│   │   ├── handler/             # HTTP 处理器
│   │   ├── service/             # 业务逻辑
│   │   │   ├── memo_service.go
│   │   │   ├── model_service.go
│   │   │   └── search_service.go
│   │   ├── repository/          # 数据访问层
│   │   ├── model/               # 数据模型
│   │   ├── config/              # 配置管理
│   │   └── pkg/                 # 内部包
│   ├── migrations/              # 数据库迁移
│   ├── proto/                   # Protocol Buffers
│   │   ├── memo.proto
│   │   ├── model.proto
│   │   └── search.proto
│   ├── tests/
│   ├── Dockerfile
│   ├── go.mod
│   └── go.sum
│
├── frontend/
│   ├── app/                     # Next.js 应用
│   │   ├── src/
│   │   │   ├── app/             # 页面
│   │   │   ├── components/      # React 组件
│   │   │   │   ├── memo/        # 笔记相关
│   │   │   │   ├── model/       # 模型相关
│   │   │   │   └── search/      # 搜索相关
│   │   │   ├── hooks/           # 自定义 hooks
│   │   │   ├── lib/             # 工具库
│   │   │   └── styles/          # 样式
│   │   ├── package.json
│   │   └── tsconfig.json
│   └── Dockerfile
│
├── desktop/
│   ├── src-tauri/               # Tauri 配置
│   ├── src/                     # React 桌面应用
│   ├── src-tauri-app/           # Tauri 应用入口
│   └── package.json
│
├── shared/
│   ├── types/
│   │   ├── memo.ts
│   │   ├── model.ts
│   │   └── search.ts
│   └── package.json
│
├── mcp-server/                  # MCP 服务器
│   ├── src/
│   └── package.json
│
├── docker-compose.yml
├── README.md
└── LICENSE
```

---

## 7. 快速起步命令

### Go 后端项目初始化
```bash
# 创建项目
go mod init github.com/yourname/prism

# 添加依赖
go get github.com/gin-gonic/gin
go get github.com/jackc/pgx/v5
go get github.com/prisma/prisma-client-go
go get github.com/grpc-ecosystem/grpc-gateway/v2

# Protocol Buffers 编译
protoc --go_out=. --go_opt=paths=source_relative \
       --go-grpc_out=. --go-grpc_opt=paths=source_relative \
       proto/memo.proto
```

### React 前端项目初始化
```bash
# 创建 Next.js 项目
pnpm create next-app@latest --typescript --tailwind

# 添加依赖
pnpm add trpc @trpc/react-query @trpc/server
pnpm add zod
pnpm add zustand
pnpm add @tanstack/react-query
```

### Prisma 初始化
```bash
# 初始化 Prisma
pnpm prisma init

# 创建迁移
pnpm prisma migrate dev --name init

# 生成 Prisma Client
pnpm prisma generate
```

---

**文档版本**: 1.0
**最后更新**: 2026-01-03
**用途**: 代码实现参考，可直接用于 Prism 重构
